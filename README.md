# Задача

Создайте программу для игры с конфетами человек против человека.

Условие задачи: На столе лежит 2021 конфета. Играют два игрока делая ход друг после друга. Первый ход определяется жеребьёвкой. За один ход можно забрать не более чем 28 конфет. Все конфеты оппонента достаются сделавшему последний ход. Сколько конфет нужно взять первому игроку, чтобы забрать все конфеты у своего конкурента?

a) Добавьте игру против бота

b) Подумайте как наделить бота "интеллектом"

# Решение
+ Создана случайная переменная `randint(1, 2)` для выбора первого ходящего.
+ Для игры с человеком и с ботом (условно "умным" и "глупым") формируем три метода, но имеющих похожий цикл, где ходы чередуются. После каждого хода количество конфет уменьшается на введенное пользователем количество. Выигрывает тот, после чего хода переменная `candies` станет равна 0.
+ Для игры с ботом сделано два варианта: глупый бот и умный бот. Первый определяет количество конфет случайным образом от 1 до 28. Второй рассчитывает количество конфет таким образом, чтобы осталось число, деляющееся на 28 с остатком 1. В случае, если полученное количество конфет расчитанно как 0, то бот ходит случайным образом, чтобы игрок не мог выявить закономерность в его поведении. Сперва было прописано, что он забирает 28 конфет, но в таком случае, если игрок постоянно будет также вводить 28, то бот обречен на поражение.Если расчитанное количество конфет больше остатка, то бот берет остаток.
### Метод хода пользователя
В данном методе добавлена проверка на ввод числа и соответсвия числа диапазону `[1, max_move]`. Проверка заключена в цикл `while`, благодаря чему пользователь может повторно пытаться вводить необходимое значение без выброса ошибки.

### Метод проверки на выигрыш
Метод короткий, но вынесен в отдельный блок. В основные методы процесса игры введена переменная `temp`, чтобы лишний раз не вызывать функцию. Мы просто запоминаем ее значение и при необходимости используем на строке 52.

Также введены ограничения в виде условия на начало проверки на выигрыш, чтобы без необходимости не тратить ресурсы компьютера. Очевидно, что выигрыш не наступит ранее, чем через 2021 // 28 ход.

Также было принято решение не вводить лишнюю переменную для подсчета ходов. Так как у нас есть переменная выбора первого хода, и она принимает занчение 0 или 1, то количество ходов при увеличении на 1 при каждой итерации будет либо равно этой переменной, либо меньше на 1. ПОэтому в условии проверки на выигрыш указываем не 2021 // 28, а 2021 // 28 - 1.